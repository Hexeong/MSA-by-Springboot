### 어려운 개발 난이도

가장 큰 원인은 다른 시스템이 네트워크상에 분산되어 있기 때문이다. 즉, 프로세스가 다른 마이크롤서비스를 개발할 때는 여러 상황을 고려해야 한다. 크게 고려할 것들은 분리된 데이터, 네트워크를 통한 데이터 통합이다. 먼저 MS들은 독립적인 데이터 저장소를 갖고 있으므로 데이터가 분리되어 있다. 그래서 **RDB의 최대 장점인 DB 트랜잭션을 사용할 수 없다**. 물론 `분산 트랜잭션`을 사용할 수 있지만, *분산 트랜잭션은 시스템 전체의 리소스를 많이 사용하므로 권장하지 않는다*. 그러므로 데이터 정합성이 맞지 않거나 중복 데이터가 발생할 수 있다.

데이터를 통합하기 위해서는 표준화된 인터페이스로 데이터를 처리해야 한다. 여러분이 반드시 기억할 것은 **네트워크는 신뢰할 수 없고, 커넥션을 맺는 비용이 비싸다는 점**이다. 네트워크는 언제든지 장애가 발생할 수 있고, 패킷은 언제든 누락될 수 있다. 요청한 응답을 받지 못하는 상황이 올 수 있고, 네트워크 지연이 발생할 수 있다.

지연 시간은 항상 일정하지 않고 상황에 따라 변한다. 그래서 개발자는 `커넥션 풀`을 이용해서 다른 MS의 API를 호출한다. 이 `커넥션 풀`을 설정할 때는 반드시 커넥션을 맺는 타임아웃과 상대방 뎅이터를 타임아웃을 고려해야 한다. 네트워크를 사용하는 데이터 통합은 전반적인 시스템 성능 하락을 가져온다. 네트워크 지연 외에도 데이터를 `직렬화/역질렬화`하는 데 비용이 발생한다.

개발자는 여러 장애 상황을 대비하는 `폴백`[^1](fallback) 기능을 고려해야 한다. 이 기능을 사용하여 어떤 경우라도 사용자에게 서비스되도록 해야 한다.
이외에도 MS를 운영하면서 발생하는 많은 어려움이 있다. 이런 부분들을 고려하고 개발해야 하므로 모놀리식 아키텍처 애플리케이션을 개발하는 것보다 난이도가 있다.

### 어려운 운영

![[그림 1-5.png]]

위의 그림 1-5는 하나의 기능을 클라이언트에 제공하려면 선으로 연결된 여러 MS의 통합된 데이터가 필요하다는 것을 보여준다. 단순히 비행기 표 예약 과정에서도 인증 MS, 예약 MS, 항공 MS가 필요하듯이 수많은 MS가 통합되어야 한다.

또한 요청이 정상적으로 처리되지 않았다면 개발자는 어느 단계에서 에러가 발생했는지 찾아야 한다. 수많은 MS 사이에서 어떤 요청이 에러였는지 찾아내기는 쉽지 않다. 특히 MSA 시스템이 낯선 개발자는 어디서 어떻게 찾아야 하는지 몰라서 허둥대기 쉽다. 물론 숙련된 개발자도 에러가 발생한 지점을 찾는 것은 쉽지 않다.

데이터가 분산되어 있기에 `분산 트랜잭션`[^6]을 사용하지 않는다면 **데이터 일관성을 유지하기 어렵다**. 만약 항공 MS가 사용자가 예약한 좌석을 정상적으로 state를 변경했다고 해도, 예약 MS가 에러를 일으켜 정상적인 데이터 생성을 못할 수도 있다. 해당 경우에는 일관성이 유지된 데이터가 아니다. 즉, 예약 기록 데이터와 항공 좌석 데이터가 일관성을 갖지 못한다고 말한다. 

이 경우 개발자가 매번 찾아서 복구해야 한다면 시스템 운영만으로도 버거워 새 기능 개발하기는 어려울 것이다. 원상 복구하려면 `스케줄링 프로세스`[^3]나 `상태 머신`[^4](state machine)과 흡사한 `사가 패턴`[^5](saga pattern)을 이용해서 예약 데이터를 지우거나 예약에 최종 실패했음을 사용자에게 알려주어야 한다. 이는 앞서 이야기한 개발 난이도가 높은 단점에도 해당한다.

### 어려운 설계

잘 설계된 MSA 시스템은 복잡한 비즈니스 로직을 개발해서 보다 쉽게 유지 보수할 수 있고, 동시에 많은 사용자 요청을 처리할 수 있다는 장점이 있다. 하지만 수많은 이유로 잘못된 방향으로 설계한다면 오히려 유지 보수하는 데 더 많은 시간이 소모된다.
또한 MS의 관계가 명확하게 구분되지 못하면 각 MS가 관리하는 데이터들이 중복될 수 있다. 이런 경우 `데이터의 파편화 현상`[^2]때문에  서비스 전체적으로 일관성 있는 데이터를 유지하기 어렵다. 또 MS의 관계가 명확하지 않다면 이들 사이에 과도한 네트워크 통신이 발생해 전체적인 시스템 성능이 저하될 수 있다.
하지만 하나의 MS 영역이 너무 크면 또 하나의 모놀리식 아키텍처가 될 수밖에 없다. 그러므로 서비스 운영 도중 다시 작은 MS로 분리하는 과정이 필요하다. MS를 분리하는 과정은 매우 자연스러운 작업이지만, 분리하는 시점을 놓치거나 시간과 인력 등 여러 이유 때문에 분리하지 못하면 점차 모놀리식 아키텍처가 될 수 있다. 그리고 전체 시스템은 그 거대한 MS에 의존하게 된다. 
**어떻게, 어느 정도 크기로 서비스를 나누어야 하는지 그 기준을 만드는 과정이 가장 힘들다**.

### 필수적인 자동화 시스템들

MSA를 도입하는 이유는 빠른 서비스 개발과 운영, 대규모 서비스를 처리하기 위해서다. 작게 분리된 MS는 적은 인원으로 빠르게 개발할 수 있다. 또한 많은 인스턴스에 빠르게 배포하기 위해 설명한 CI/CD 시스템이 필요하다. 

대규모 서비스이므로 수십 혹은 수백 개의 인스턴스가 하나의 서비스처럼 동작한다. 수많은 인스턴스를 사람의 손으로 일일이 모니터링하기 불가능하므로 모니터링 시스템도 필요하다. 이 모니터링 시스템은 각 시스템의 리소스 지표를 모니터링하는 것 뿐만 아니라 문제가 발생하면 빠른 시간 안에 개발자에게 알림을 보내야 한다.

CPU, 메모리, 디스크 사용량, 네트워크 등의 정보와 애플리케이션 성능 정보를 같이 볼 수 있어야 효과적인 모니터링이 가능하다. 수많은 장비에서 발생하는 로그도 개발자가 장비에 접속해서 찾아보는 일도 불필요한 작업이다. 그래서 로그를 통합해서 검색해 주는 시스템이 필요하다. 이외 자동화된 여러 시스템을 효과적으로 요구한 곳에 사용하는 것도 필요하다. 이런 자동화된 시스템들을 운영하고 유지 보수하는 것도 쉬운 일은 아니다.

### 요구되는 개발자의 높은 기술력

하나의 MS 개발 속도는 개발자 숫자와 비례해서 선형적으로 증가하지 않는다. 오히려 사람이 많을 수록 사람 사이에서 발생하는 커뮤니케이션 시간과 노력은 기하급수적으로 증가한다. 그래서 하나의 MS를 개발하는 팀은 적은 인원을 유지하도록 한다. 이 인원이 적은 팀은 시스템 운영부터 개발까지 수많은 일을 처리해야 한다. 필자는 MS가 개발과 운영이 어려운 서비스라고 이미 말했다. 각 팀원의 기술 성숙도가 낮은 팀은 MS를 하기에 부적합하며, 오히려 개발 속도와 서비스 안정성 면에서 역효과가 발생해야 한다.

---

[^1]: 네트워크가 정상적이지 않거나 다른 MS가 운영이 불가능한 상태일 때 이를 대비하는 기능을 의미한다.

[^2]: ### 파편화의 의미
	
	1. **데이터 중복**: 여러 마이크로서비스가 동일한 데이터를 각자 관리하게 되면, 동일한 정보가 여러 위치에 중복되어 저장될 수 있습니다. 예를 들어, 사용자 정보가 A 서비스와 B 서비스에 각각 존재할 경우, 사용자가 변경되면 모든 서비스에서 해당 데이터를 일관되게 업데이트해야 하는 문제가 생깁니다.
	    
	2. **데이터 일관성 문제**: 각 마이크로서비스에서 데이터를 중복 관리하게 되면, 일부 서비스에서만 데이터가 변경되거나 업데이트되는 상황이 발생할 수 있습니다. 이는 데이터 간의 일관성을 깨뜨리며, 사용자가 서로 다른 서비스에서 다른 데이터를 보게 되는 문제가 발생할 수 있습니다.
	    
	
	### 데이터의 파편화와 일관성 문제
	
	이 문맥에서 "데이터의 파편화 현상"은 **여러 마이크로서비스에 걸쳐 데이터가 분산되고 중복되면서 생기는 비일관성 문제**를 지칭합니다. 이는 일반적인 데이터 파편화 현상과 유사한 맥락에서 설명될 수 있는데, 데이터가 여러 위치에 분산되고 관리되지 않으면 일관성을 유지하기 어려워지는 현상을 의미합니다.
	
	- **데이터의 파편화**가 일어나면, 마이크로서비스 간의 데이터 동기화가 어려워지고, 각 서비스에서 관리하는 데이터가 서로 다른 상태가 될 가능성이 높아집니다.
	- **일관성 유지의 어려움**: 각 서비스가 자체적으로 데이터를 처리하고 중복 관리할 때, 데이터가 실시간으로 동기화되지 않으면 서비스 전체에서 일관성 있는 데이터를 유지하는 것이 어렵습니다.
	
	따라서 데이터의 파편화 현상이란 마이크로서비스 환경에서 **데이터가 여러 서비스에 중복되고 일관성 없이 관리되면서 생기는 문제**를 의미한다고 볼 수 있습니다. 이를 해결하려면 서비스 간의 명확한 데이터 책임 구분과 일관성 관리 전략이 필요합니다.

[^3]: 스케줄링 프로세스는 일정한 시간 간격으로 특정 작업을 실행하는 프로세스입니다. 이를 통해 정해진 시간에 데이터 백업, 예약된 작업 실행, 만료된 데이터 정리 등 자동화된 작업을 수행할 수 있습니다.
	
	- 예: **Cron Job**이나 **Spring Scheduler**와 같은 기술이 스케줄링 프로세스의 예입니다. 예약된 데이터를 주기적으로 확인하고 삭제하거나, 실패한 트랜잭션을 복구할 때 사용됩니다.

[^4]: 상태 머신은 **어떤 객체가 특정한 상태(state)를 가지며, 그 상태들이 변화하는 과정에서 특정한 규칙을 따르는 시스템**을 의미합니다. 상태는 서로 전이(transitions)를 통해 이동하며, 이러한 상태 전이가 시스템의 흐름을 제어합니다.
	
	- 예: 예약 프로세스에서 '예약 요청됨' → '예약 처리 중' → '예약 완료' 또는 '예약 실패'로 상태가 전이되는 것이 상태 머신의 예입니다. 이를 통해 예약 데이터의 상태 변화를 추적하고 관리할 수 있습니다.

[^5]: 사가 패턴은 **분산된 마이크로서비스 환경에서 긴 트랜잭션을 관리하는 패턴**입니다. 하나의 긴 트랜잭션을 여러 서비스에 걸쳐 나누어 처리하며, 각 서비스의 로컬 트랜잭션이 완료되면 다음 서비스로 넘어갑니다. 만약 어느 한 서비스에서 오류가 발생하면 이전에 완료된 트랜잭션을 취소하는 보상 작업(compensation)을 수행해 시스템의 일관성을 유지합니다.
	
	- **사가 패턴의 주요 특징**:
	    - **연속된 로컬 트랜잭션**: 여러 마이크로서비스가 각각 독립적으로 로컬 트랜잭션을 수행하고, 트랜잭션이 성공하면 다음 서비스로 넘어갑니다.
	    - **보상 작업**: 트랜잭션이 실패할 경우, 이미 완료된 트랜잭션을 되돌리는 보상 작업을 실행하여 데이터의 일관성을 유지합니다.
	    - 예: 예약 요청이 여러 서비스에서 처리될 때, 중간에 실패가 발생하면 이미 처리된 작업들을 되돌리거나, 사용자에게 최종 실패를 알릴 수 있습니다.

[^6]: 분산 트랜잭션(Distributed Transaction)은 여러 독립적인 시스템이나 서비스(일반적으로 마이크로서비스)에서 하나의 트랜잭션을 수행하는 방식입니다.
	
	### 분산 트랜잭션의 특징
	
	- **여러 노드/서비스에 걸친 트랜잭션**: 하나의 트랜잭션이 여러 데이터베이스나 마이크로서비스를 거쳐 처리됩니다. 예를 들어, 하나의 트랜잭션 내에서 결제 서비스와 재고 관리 서비스가 모두 성공적으로 완료되어야 트랜잭션이 완료됩니다.
	- **ACID 속성 보장**: 분산 환경에서도 원자성(Atomicity) 등 트랜잭션의 핵심 속성을 유지하기 위해 조정이 필요합니다. 모든 트랜잭션이 성공해야 최종적으로 커밋되고, 그렇지 않으면 모든 변경 사항이 롤백됩니다.
	
	### 해결 방법
	
	1. **2PC (Two-Phase Commit)**: 분산 트랜잭션을 관리하는 전통적인 방법으로, 두 단계로 나누어 트랜잭션을 커밋하는 방식입니다. 첫 단계에서는 모든 참여자가 준비 상태인지 확인하고, 두 번째 단계에서 트랜잭션을 최종적으로 커밋하거나 롤백합니다.
	    
	2. **사가 패턴**: 마이크로서비스 환경에서 많이 사용하는 트랜잭션 관리 패턴으로, 트랜잭션을 여러 개의 로컬 트랜잭션으로 분리하고 각 트랜잭션이 실패하면 보상 작업을 실행하는 방식입니다.
