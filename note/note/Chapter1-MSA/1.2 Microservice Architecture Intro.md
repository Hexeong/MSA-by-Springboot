그림 1-3은 MSA를 표현한 것이다. 모놀리식 아키텍처를 설명한 그림 1-1의 애플리케이션 서버는 JS, HTML, Servlet 등 기술 위주로 설명되어 있다. 

하지만 그림 1-3은 기능 위주로 애플리케이션이 설명되어 있다. `MSA`는 **기능 위주로 나뉜 여러 애플리케이션이 있고, 각각 독립된 데이터 저장소를 사용**한다. 기능으로 분리된 애플리케이션들은 미리 정의된 인터페이스를 통해 서로 유기적으로 동작한다. 그리고 웹이나 APP 클라이언트에 일관된 형태의 API로 제공된다. 그림 1-3에선 예약 MS, 항공 MS, 호텔 MS로 기능이 분리되어 있다. 인증 또한 MS가 될 수 있다.

>[!note]
>`DDD(Domain Driven Design)`에서 나온 도메인 Bounded Context에 따라서 **보통 마이크로 서비스의 가지수가 결정된다.**
>
>DDD에서 나온 `도메인` 개념은 소프트웨어가 해결하고자 하는 특정 문제 영역으로 정의될 수 있고, `Bounded Context`는 도메인을 분리하여 각 부분이 독립적으로 관리될 수 있도록 만든 구역이라고 할 수 있다. 

![[그림 1-3.png]]

마이크로서비스 아키텍처의 특징을 대표하는 몇 가지 키워드가 있다. 대규모 시스템, 분산 처리 시스템, 컴포넌트들의 집합 그리고 시스템 확장 등이다. 이런 특징들은 `서비스 지향 아키텍처(Service Oriented Architecture, SOA)`와 공통점이 많다.

>[!tip]
>서비스 지향 아키텍처는 대규모 시스템을 설계할 때, 서비스 기능 단위로 시스템을 묶어 시스템 기능을 구현한 것을 의미한다. 그래서 서비스 지향 아키텍처와 마이크로서비스 아키텍처는 공통점이 많다. **두 아키텍처 모두 서비스 기능 단위로 시스템을 만들고, 각 시스템은 서로 표준화된 인터페이스를 통해 서비스를 통합한다.** 이처럼 핵심 개념은 서로 같다. 몇몇 사람은 MSA가 서비스 지향 아키텍처의 설계를 따르면서 발전시킨 최신 아키텍처라고 말한다. 
>
>두 아키텍처 모두 엔터프라이즈 시스템이라는 `대규모 시스템을 구축하기 위한 것`이다. 그러므로 기능이 복잡하고 처리량이 많은 시스템에 적합하며, 기능이 복잡한 시스템을 편리하게 개발하고 운영하기 위해 소프트웨어 기능을 서비스 단위로 분류하고, 컴포넌트들은 네트워크를 통해 데이터를 통합한다.

**MSA의 MS들은 각각 다른 MS에서 독립적으로 구성되어야 한다**. 스파게티 코드처럼 MS들이 서로 의존하면 복잡도는 더욱 증가한다 개발 속도와 운영도 문제이지만, MSA 하나에 장애가 발생하면 연쇄적으로 장애가 발생하는 `단일 장애 지점`이 더 큰 문제다. 결국 각 마이크로서비스는 독립적으로 동작해야 하고 다른 MS에 의존성을 최소화해야 한다.

이를 **느슨한 결합**이라고 한다. 그러므로 MS마다 각각 독립된 데이터 저장소가 필요하다. 

>[!note]
>그 외에도 만약 **데이터 저장소를 공유하게 된다면** 이는 단일 장애 지점이 될수도 있다. 또한 다른 MS가 데이터 저장소를 전부 차지할 수 있다는 잠재적 문제점도 있어 데이터 저장소를 공유하는 것은 대규모 시스템에서 문제가 될 수 있다.
>

앞서 이야기 한 MSA에서 MS들이 느슨하게 결합되어 각각 독립성을 갖도록 한다는 말은 다시 말하면 서비스 전체 기능을 개발할 때는 칼로 자르듯 MS들을 분리할 수는 없다는 말과 같다.

여러 MS 기능이 조합되어 하나의 서비스 기능을 제공할 수 있다. 그림 1-3에서 보면, 호텔 정보를 조회하는 기능은 호텔 MS가 담당할 수 있다. 하지만 호텔과 항공, 상품을 일괄 결제하는 기능은 여러 MS 기능이 조합되어야 한다. 이때 *데이터는 서로 분리되어 있으므로* 각 MS는 **네트워크를 통해 서로 기능을 통합해야 한다**.

기능이 각각 분리되어야 한는 동시에 서로 결합되어야 한다. 그래서 MS는 설계도 어렵고, 개발할 때 더 많은 신경을 써야 한다.

>[!warning]
>설계 시, **MS들은 기능과 성격에 맞게 잘 분리**되어야 하고, 그렇다고 *기능이 너무 작게도 혹은 너무 크게도 설계되어서는 안 된다*. 기능을 너무 세밀하게 분리하면 수많은 MS들을 관리해야 하고, 데이터 저장소도 잘게 쪼개지기에 간단한 기능이라도 여러 MS의 기능 통합이 필요하다. 반대로 기능을 너무 크게 설계하면 커다란 기능을 가진 하나의 MS가 되서 모놀리식 아키텍처와 다를바 없다. 때문에 서비스 전체가 하나의 MS에 의존하게 된다.

>[!tip]
>현실적으로 한 번에 서비스 기능을 잘 분리하여 MSA를 설계하는 것은 매우 어려운 일이다. 포기 설계 단계부터 완벽하게 설계할 수 없음을 기억하자. 운영 도중에 MS를 다시 쪼개기도 하고, 너무 작은 MS들을 합치기도 한다. 이런 과정을 거친 MS는 시스템 독립성을 갖게 된다.

각 MS 컴포넌트들은 기능을 연동할 때, API를 통해 서로 데이터를 주고받는다. 원래 모놀리식에서 데이터를 주고받을 때는 애플리케이션 서버 내에서 데이터를 주고 받는데 `overhead`가 발생한 거라면, MSA는 네트워크에서 데이터를 주고 받는데 `overhead`가 발생하게 된다.
다시 말하면 API가 사용하는 **네트워크 프로토콜이 성능 저하의 원인**이 될 수 있다. 그러므로 통신에 사용되는 네트워크 프로토콜은 가벼워야 한다. 네트워크를 통해 MS 사이에 데이터를 전달하려면 객체는 바이트 형태로 변경되어야 한다. 이렇게 **데이터를 바이트로 변경하는 과정**을 `직렬화/역직렬화`라고 한다.
직렬화된 바이트 데이터가 원래의 객체 크기보다 훨씬 크다면(사진 등) 네트워크에서 성능 저하가 발생한다. 또한 직렬화/역직렬화 과정에서 CPU와 메모리 같은 시스템 리소스를 많이 사용하면 시스템의 전반적인 성능 저하가 발생한다. 그러므로 시스템의 전반적인 성능 최적화를 위해 가벼운 프로토콜을 사용해야 한다.
보통은 `JSON` 형식으로 주고 받으며 HTTP 기반의 REST-API를 가장 많이 사용한다. 이외에도 `gRPC`나 `Thrift`, `Avro`, `Protobuffer` 등을 사용한다. 그리고 비동기 처리를 위해 `AMQP` 프로토콜을 사용하는 메세징 큐 시스템 기반으로 데이터를 주고받는다. 메시징 큐 시스템 기반의 데이터 교환은 REST-API 기반의 통신보다 높은 신뢰성을 제공하는 장점이 있지만, MS 사이에 메시징 큐 시스템에 의존성이 생기는 단점이 있다. 그래서 메시지 큐가 단일 장애 지점이 되기도 한다.

> [!note]
> `gRPC`나 `Thrift`, `Avro`, `Protobuffer` 모두 RPC(Remote Procedure Call) 또는 데이터 직렬화와 관련된 기술입니다.
> 1. gRPC
> 	- gRPC는 구글이 개발한 오픈소스 RPC 프레임워크로 HTTP/2 기반의 Protocol Buffer를 직렬화 포맷으로 사용합니다.
> 	- 다중 언어 지원, 양방향 스트리밍 지원, 자동 코드 생성 같은 기술이 있습니다.
> 2. Apache Thrift
> 	- Thrift는 페이스북이 개발한 RPC 프레임워크로 다중 언어 간의 서비스 통신을 쉽게 하기 위해 만들어졌습니다.
> 	- 다중 언어 지원, 다양한 전송 및 프로토콜 옵션, 멀티 프로토콜을 지원합니다.
> 3. Apache Avro
> 	- Apache Hadoop에서 주로 사용되는 데이터 직렬화 시스템입니다.
> 	- 스키마 기반, JSON 기반의 유연한 데이터 포맷, Hadoop과의 통합성, 역호환성 등의 특징이 존재합니다.
> 4. Protocol Buffer (Protobuffer)
> 	- **Protocol Buffers**는 구글이 개발한 언어 중립적, 플랫폼 중립적인 직렬화 포맷으로, **gRPC**에서 사용되는 직렬화 포맷이기도 합니다.
> 	- 빠르고 가벼움, 스키마 기반, 자동 코드 생성, 역호환성 등의 특징을 가지고 있습니다.

>[!note]
>**AMQP**는 메시지 브로커 시스템에서 **메시지 큐잉**을 처리하는 **프로토콜**입니다. 주로 **RabbitMQ** 같은 메시지 브로커에서 사용됩니다. **발행-구독 모델**과 **큐 기반 메시지 전달**을 지원하여, 메시지를 특정 큐로 보내고, 소비자가 큐에서 메시지를 가져가는 구조입니다.
>**Kafka**는 **분산 스트리밍 플랫폼**으로, 실시간 데이터 스트리밍에 강점이 있습니다. `토픽(Topic)`을 통해 메시지를 관리하고, `생산자(Producer)`가 메시지를 토픽에 기록하면 **소비자(Consumer)**는 토픽에서 메시지를 읽어갑니다. Kafka는 메시지를 큐에서 제거하지 않고 **로그**로 저장하여 여러 소비자가 독립적으로 읽을 수 있도록 합니다.
>
>Kafka를 AMQP처럼 사용하는 방식은 `소비자 그룹을 큐처럼 사용`하고, `토픽을 통해 메시지를 라우팅하는 구조`로 설계하는 것을 의미합니다. 또한, Kafka Streams를 사용해 메시지 처리를 좀 더 유연하게 구현할 수 있으며, 이를 통한 복잡한 라우팅이나 필터링 기능도 가능해집니다.

>[!summary]
>MSA의 특징을 정리해보자
>- 잘 분리된 MS로 인한 탈중앙화
>- 대규모 시스템을 위한 아킨텍처
>- 가벼운 네트워크 프로토콜
>- 느슨한 결합
>- 서비스 지향 아키텍처

